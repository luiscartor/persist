# with the response variable values
if (fileType==1) {
xy <- read.dbf(pointData)[,c(x_coord, y_coord)]
responseVar <- as.numeric(read.dbf(pointData)[,responseVar])
} else if (fileType==2) {
pointTable <- read.table(pointData, header=TRUE, sep=",")
xy <- SpatialPoints(pointTable[,c(x_coord, y_coord)])
responseVar <- as.numeric(pointTable[,responseVar])
}
# Sample xy and responce if numSamps is not -1
#
if (numSamps != -1) {
if (numSamps > length(xy[,1])) {
cat("\n\n*****************************************************************************")
cat("\nThe variable numSamps is greater than the total number of points available to be randomly sampled\n")
cat("Please change numSamps to be smaller than", length(xy[,1]), "which is the total number of sample points.\n\n")
stop("Change the value for numSamps and then restart the script\n\n", call.=FALSE)
}
sampIdx = sample(seq(1, length(xy[,1])), size=numSamps)
xy = xy[sampIdx,]
responseVar = responseVar[sampIdx]
}
# Load the input predected image then flag all no-data values (nd) so they are not processed
predImage <- raster(inImage)
NAvalue(predImage) <- nd
# Get pixel responseVar values from the image under each sample point and create a table with
# observed and predicted responseVar values
cat("Getting the pixel values under each point\n")
samples <- cbind(responseVar, extract(predImage, xy))
# Remove NA values from trainvals table created above
samples <- na.omit(samples)
# Calculate blocksize for image writing at the end of the script
bs <- blockSize(predImage)
# Get output data type from the input image
dataType <- dataType(predImage)
samplesX <- samples[,2] # Predicted values from the input image
samplesY <- samples[,1] # Observed values from training data
cat("Plot graphs\n")
if (regType==1) {
fit <- mblm(samplesY ~ samplesX, repeated=TRUE)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=1)
abline(lm(samplesY ~ samplesX), lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
}
} else if (regType==2) {
fit <- lm(samplesY ~ samplesX)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else if (regType==3) {
fit <- lm(samplesY ~ samplesX+0)
slope <- fit$coefficients[1]
intercept <- 0
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=3)
abline(lm(samplesY ~ samplesX), lty=2)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else {
cat("\n   The variable regType must be an integer between 1 and 3 \n\nEnter Q to quit\n\n")
browser()
}
require(maptools)
require(sp)
require(randomForest)
require(raster)
require(rgdal)
require(mblm)
#############################   SET VARIABLES HERE  ###################################
#
# Enter a 1 if the response variable training data are in a .dbf file or 2 if the data are in a CSV format
# with a header
fileType <- 2
# The CSV or DBF file containing X, Y, and response variable (i.e., biomass, % cover...) data.
pointData <- 'C:/Peatlands_regression/outsamples.csv'
# Name and path for the input predicted image
inImage <-'peakdisctrict_barepeat_regression_aerialmask.tif'
# Name and path of the output adjusted image
outImage <-'peakdisctrict_barepeat_regression_aerialmask_corrected.tif'
# No-data value for the input image
nd <- -1
# Enter EITHER the name (case sensitive and in quotes) or the column number of the
# field containing X coordinates
x_coord <- "X"
# Enter EITHER the name (case sensitive and in quotes) or the column number of the
# field containing Y coordinates
y_coord <- "Y"
# Enter EITHER the name (case sensitive and in quotes) or the column number of the
# field containing the response variable values
responseVar <- "pct_cover"
# Minimum valid output value
minValue <- 0
# Maximum valid output value
maxValue <- 1
# Number of points to be randomly sampled. Enter -1 to use all sample points. It
# may be necessary to use a subset of the sample points to avoid memory problems.
numSamps <- -1
#
# Type of regression to be applied- 1 = Theil-Sen Siegel repeated medians, 2 = linear,
#                                   3 = linear with intercept of 0
regType = 2
#
# Display regression graphs and compare different models (TRUE or FALSE)?
# Solid line shows regression for Theil-Sen Siegel repeated medians
# Dashed line shows regression for linear regression
# Dotted line shows regression for linear regression with intercept of 0
# Display a graph?
dispGraphs = TRUE
#############################################################################
# Start processing
cat("Set variables and start processing\n")
startTime <- Sys.time()
cat("Start time", format(startTime),"\n")
# Read the data in the dbf or CSV file and create a table of XY values and another
# with the response variable values
if (fileType==1) {
xy <- read.dbf(pointData)[,c(x_coord, y_coord)]
responseVar <- as.numeric(read.dbf(pointData)[,responseVar])
} else if (fileType==2) {
pointTable <- read.table(pointData, header=TRUE, sep=",")
xy <- SpatialPoints(pointTable[,c(x_coord, y_coord)])
responseVar <- as.numeric(pointTable[,responseVar])
}
# Sample xy and responce if numSamps is not -1
#
if (numSamps != -1) {
if (numSamps > length(xy[,1])) {
cat("\n\n*****************************************************************************")
cat("\nThe variable numSamps is greater than the total number of points available to be randomly sampled\n")
cat("Please change numSamps to be smaller than", length(xy[,1]), "which is the total number of sample points.\n\n")
stop("Change the value for numSamps and then restart the script\n\n", call.=FALSE)
}
sampIdx = sample(seq(1, length(xy[,1])), size=numSamps)
xy = xy[sampIdx,]
responseVar = responseVar[sampIdx]
}
# Load the input predected image then flag all no-data values (nd) so they are not processed
predImage <- raster(inImage)
NAvalue(predImage) <- nd
# Get pixel responseVar values from the image under each sample point and create a table with
# observed and predicted responseVar values
cat("Getting the pixel values under each point\n")
samples <- cbind(responseVar, extract(predImage, xy))
# Remove NA values from trainvals table created above
samples <- na.omit(samples)
# Calculate blocksize for image writing at the end of the script
bs <- blockSize(predImage)
# Get output data type from the input image
dataType <- dataType(predImage)
samplesX <- samples[,2] # Predicted values from the input image
samplesY <- samples[,1] # Observed values from training data
cat("Plot graphs\n")
if (regType==1) {
fit <- mblm(samplesY ~ samplesX, repeated=TRUE)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=1)
abline(lm(samplesY ~ samplesX), lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
}
} else if (regType==2) {
fit <- lm(samplesY ~ samplesX)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else if (regType==3) {
fit <- lm(samplesY ~ samplesX+0)
slope <- fit$coefficients[1]
intercept <- 0
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=3)
abline(lm(samplesY ~ samplesX), lty=2)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else {
cat("\n   The variable regType must be an integer between 1 and 3 \n\nEnter Q to quit\n\n")
browser()
}
print(fit)
fit
print(fit)
summary(fit)
fit$fitted.values
fit$coefficients
fit$qr
fit$terms
summary(fit)$r.squared
print(fit, main=paste("R = ",summary(fit)$r.squared,sep=""))
print(fit, main=paste("R = ",summary(fit)$r.squared,sep=""))
paste("R = ",summary(fit)$r.squared,sep="")
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed", main=paste("R = ",summary(fit)$r.squared,sep=""))
# Calculate blocksize for image writing at the end of the script
bs <- blockSize(predImage)
# Get output data type from the input image
dataType <- dataType(predImage)
samplesX <- samples[,2] # Predicted values from the input image
samplesY <- samples[,1] # Observed values from training data
cat("Plot graphs\n")
if (regType==1) {
fit <- mblm(samplesY ~ samplesX, repeated=TRUE)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed", main=paste("R2 = ",summary(fit)$r.squared,sep=""))
abline(fit, lty=1)
abline(lm(samplesY ~ samplesX), lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
}
} else if (regType==2) {
fit <- lm(samplesY ~ samplesX)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else if (regType==3) {
fit <- lm(samplesY ~ samplesX+0)
slope <- fit$coefficients[1]
intercept <- 0
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed")
abline(fit, lty=3)
abline(lm(samplesY ~ samplesX), lty=2)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else {
cat("\n   The variable regType must be an integer between 1 and 3 \n\nEnter Q to quit\n\n")
browser()
}
cat("Plot graphs\n")
if (regType==1) {
fit <- mblm(samplesY ~ samplesX, repeated=TRUE)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed", main=paste("R2 = ",summary(fit)$r.squared,sep=""))
abline(fit, lty=1)
abline(lm(samplesY ~ samplesX), lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
}
} else if (regType==2) {
fit <- lm(samplesY ~ samplesX)
slope <- fit$coefficients[2]
intercept <- fit$coefficients[1]
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed", main=paste("R2 = ",summary(fit)$r.squared,sep=""))
abline(fit, lty=2)
abline(lm(samplesY ~ samplesX+0), lty=3)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else if (regType==3) {
fit <- lm(samplesY ~ samplesX+0)
slope <- fit$coefficients[1]
intercept <- 0
if (dispGraphs) {
plot(samplesX, samplesY, xlab="Predicted", ylab="Observed", main=paste("R2 = ",summary(fit)$r.squared,sep=""))
abline(fit, lty=3)
abline(lm(samplesY ~ samplesX), lty=2)
abline(mblm(samplesY ~ samplesX), lty=1)
}
} else {
cat("\n   The variable regType must be an integer between 1 and 3 \n\nEnter Q to quit\n\n")
browser()
}
source('C:/Peatlands_regression/rf_percentCover_edit.R')
source('C:/Peatlands_regression/Script-rsbiodiv-randomforestpercentcover/CorrectRF_Result.R')
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
cols1 <- rbind(c(1,2),c(1,1))
cols1
cols1 <- rbind(c(1,2),c(1,1),c(1,3),c(2,2))
cols2 <- rbind(c(1,2),c(1,1),c(1,3)
)
cols2
cols1
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
area <- (max(xy1[,1])-min(xy1[,1]))*(max(xy1[,2])-min(xy1[,2]))
area
xy1 <- cols1
xy2 <- cols2
area <- (max(xy1[,1])-min(xy1[,1]))*(max(xy1[,2])-min(xy1[,2]))
area
csp_max <- -smnnd(xy1,xy1,area)
csp_max
csp_min <- c()
csp_min <- c()
for(i in 1:1000){
ran_cols <- c()
for (j in 1:nrow(xy1)){
ran_col <- c(sample(min(xy1[,1]):max(xy1[,1]),1),sample(min(xy1[,2]):max(xy1[,2]),1))
ran_cols <- rbind(ran_cols,ran_col)
colnames(ran_cols) <- colnames(xy1)
}
csp_min <- c(csp_min,csp(ran_cols,xy1,area))
}
csp_min
ran_cols
area
cols1
max(xy1[,2])
area <- (max(xy1[,1])-min(xy1[,1]))*(max(xy1[,2])-min(xy1[,2]))
area
max(xy1[,2])-min(xy1[,2])
cols1 <- rbind(c(1,1),c(2,2),c(7,10),c(4,2))
cols2 <- rbind(c(1,1),c(8,1),c(7,10),c(5,6))
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cols2 <- rbind(c(1,1),c(8,1),c(7,10),c(5,6),c(13,8),c(2,3))
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
devtools::load_all(".")
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cols2 <- rbind(c(1,1),c(8,1),c(7,10),c(5,6)
)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols2)
cspscaled(cols1,cols1)
cspscaled(cols1,cols1)
devtools::load_all(".")
devtools::load_all("persist")
library(gplots)
library(rgdal)
devtools::load_all("persist")
library(gplots)
library(rgdal)
library(persist)
library(persist)
year <- c(1985:2013)
year
filelist = list.files(pattern = ".*.txt")
filelist
filelist = list.files(pattern = "*.txt")
setwd("~/Documents/research/phd/research/chapter3/philopatry/NNeigh")
filelist = list.files(pattern = ".*.txt")
filelist
filelist = list.files(pattern = ".*utm.txt")
filelist
filelist = list.files(pattern = "/coloniesdata/.*utm.txt")
filelist
filelist = list.files(pattern = "//coloniesdata//.*utm.txt")
filelist
filelist = list.files(pattern = "coloniesdata//.*utm.txt")
filelist
filelist = list.files(pattern = "coloniesdata//*utm.txt")
filelist
filelist = list.files(pattern = "/coloniesdata/.*utm.txt")
filelist
filelist = list.files(pattern = "/coloniesdata/*utm.txt")
filelist
filelist = list.files(path = "/coloniesdata",pattern = ".*.utm.txt")
filelist
filelist = list.files(path = "/coloniesdata",pattern = "*.utm.txt")
filelist
filelist = list.files(path = "/coloniesdata/",pattern = "*.utm.txt")
filelist
filelist = list.files(path = "coloniesdata/",pattern = "*.utm.txt")
filelist
clnslist <- lapply(filelist, list())
filelist
clnslist <- c()
for(i in 1:length(filelist)){clnslist[[i]] <- filelist[1]}
clnslist[[1]]
clnslist <- c()
for(i in 1:length(filelist)){clnslist[[i]] <- read.table(filelist[1])}
clnslist <- c()
for(i in 1:length(filelist)){clnslist[[i]] <- read.table(paste("coloniesdata/",filelist[1],sep="")}
clnslist <- c()
for(i in 1:length(filelist)){clnslist[[i]] <- read.table(paste("coloniesdata/",filelist[1],sep=""))}
clnslist
clnslist[[1]]
year <- c(1985:2013)
year
??cspscaled
?cspscaled
??csp
??persist
?persist
pers <- c()
for(i 2:length(clnslist)){
pers <- c(pers, cspscaled(clnslist[[i]],clnslist[[i-1]]))
}
pers <- c()
for(i 2:length(clnslist)){
pers <- c(pers, cspscaled(clnslist[[i]],clnslist[[i-1]]))
}
for(i in 2:length(clnslist)){
pers <- c(pers, cspscaled(clnslist[[i]],clnslist[[i-1]]))
}
devtools::load_all("~/Desktop/persist")
source('~/Documents/research/phd/research/chapter3/philopatry/NNeigh/sfpapermain.R')
devtools::load_all("~/Desktop/persist")
pers <- c()
for(i in 2:length(clnslist)){
pers <- c(pers, cspscaled(clnslist[[i]],clnslist[[i-1]]))
}
devtools::load_all("~/Desktop/persist")
pers
cspscaled(clnslist[[i]],clnslist[[i-1]])
clnslist[[1]]
clnslist[[2]]
clnslist[[21]]
filelist = list.files(path = "coloniesdata/",pattern = "*.utm.txt")
clnslist <- c()
for(i in 1:length(filelist)){clnslist[[i]] <- read.table(paste("coloniesdata/",filelist[1],sep=""))}
clnslist
filelist = list.files(path = "coloniesdata/",pattern = "*.utm.txt")
clnslist <- c()
for(i in 1:length(filelist)){clnslist[[i]] <- read.table(paste("coloniesdata/",filelist[i],sep=""))}
pers <- c()
for(i in 2:length(clnslist)){
pers <- c(pers, cspscaled(clnslist[[i]],clnslist[[i-1]]))
}
pers
plot(pers)
# Read Italy data
clnDataFile <- "./NorthItalyDataReduced.rdt"
d <- read.table(clnDataFile,h=T)
year <- seq(1972,2013,1)
#add each year colony locations to list
clnslistIt <- list()
for(i in 1:length(year)){
w <- year[i]
clnmxy.w <- d[d[,"year"]==w,]
xy.w.utm <- t(apply(clnmxy.w[,5:4],1,ll2utm,
utmcrs="+proj=utm +zone=32 +datum=WGS84"))
clnmxy.w.utm <- data.frame(x=xy.w.utm[,1],y=xy.w.utm[,2])
clnslistIt[[i]] <- clnmxy.w.utm
}
clnslistIt
persIt <- c()
for(i in 2:length(clnslistIt)){
persIt <- c(persIt, cspscaled(clnslistIt[[i]],clnslistIt[[i-1]]))
}
persIt
